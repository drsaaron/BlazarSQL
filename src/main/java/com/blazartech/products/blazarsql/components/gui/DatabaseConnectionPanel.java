/*
 * DatabaseConnectionPanel.java
 *
 * Created on April 9, 2004, 3:52 PM
 */

package com.blazartech.products.blazarsql.components.gui;

import com.blazartech.products.blazarsql.components.gui.editor.SQLEditor;
import com.blazartech.products.blazarsql.components.gui.editor.jsyntax.SQLEditorJSyntaxPaneImpl;
import com.blazartech.util.gui.exception.ExceptionDisplayPanel;
import com.blazartech.products.blazarsql.components.dataobjects.ConnectionManager;
import com.blazartech.products.blazarsql.components.dataobjects.DBConnection;
import com.blazartech.products.blazarsql.components.writer.ResultSetWriter;
import java.awt.FontMetrics;
import java.io.IOException;
import java.io.Writer;
import java.sql.*;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import jakarta.inject.Provider;
import javax.swing.*;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.table.TableModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

/** A graphical component to represent a database connection.  The panel will be
 * divided into an {@link SQLEditorJSyntaxPaneImpl} and an area in which query results may be
 * displayed.  For queries that return {@link java.sql.ResultSet}'s, the query
 * results will be shown in a {@link javax.swing.JTable}.  A string query results,
 * likely from the object browser, will be displayed in {@link
 * javax.swing.JTextArea} component.
 *
 * @author Dr. Scott E. Aaron
 * @version $Id: DatabaseConnectionPanel.java 30 2015-04-23 19:52:54Z aar1069 $
 */

/* $Log: DatabaseConnectionPanel.java,v $
/* Revision 1.12  2008/02/11 22:51:24  aar1069
/* fixed the saving of query results
/*
/* Revision 1.11  2008/01/24 22:01:34  aar1069
/* Use the new ResultSetTable instead of a straight JTable to show result sets.
/*
/* Revision 1.10  2008/01/24 21:25:55  aar1069
/* Handle null values.
/*
/* Revision 1.9  2008/01/24 21:14:28  aar1069
/* The model does not just store strings, so call the toString method to get the value to a string.
/*
/* Revision 1.8  2007/07/17 20:22:56  AAR1069
/* Some code clean up.  Use more imports rather than fully qualified class names.  Remove a big block of commented out code from the query execution method.
/*
/* Revision 1.7  2007/07/17 19:29:07  AAR1069
/* no message
/*
/* Revision 1.6  2007/07/17 19:18:57  AAR1069
/* no message
/*
/* Revision 1.5  2007/01/03 21:37:39  aar1069
/* For the table result display, wrap the result set model in a table
/* sorter model to allow the table to be sorted by the user.
/*
/* Revision 1.4  2006/11/01 23:16:41  aar1069
/* Added an object browser to the input side.  The user can toggle between the
/* SQL editor and the object browser.
/*
/* Revision 1.3  2006/10/02 21:18:36  aar1069
/* On exception log the exception.
/*
/* Revision 1.2  2006/10/02 21:11:07  aar1069
/* Only call getUpdateCount once.
/*
 *******************************************************************************/
@Component
@Scope("prototype")
public class DatabaseConnectionPanel extends JPanel implements InitializingBean {
    private static final Logger logger = LoggerFactory.getLogger(DatabaseConnectionPanel.class);
    
    /** Creates new form DatabaseConnectionPanel
     * @throws java.lang.Exception */
    @Override
    public void afterPropertiesSet() throws Exception {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        _resultScroller = new javax.swing.JScrollPane();
        _inputToggleGroup = new javax.swing.ButtonGroup();
        _splitter = new javax.swing.JSplitPane();
        _inputPanel = new javax.swing.JPanel();
        _inputScroller = new javax.swing.JScrollPane();
        _editor = editorProvider.get();
        jPanel2 = new javax.swing.JPanel();
        _sqlInputButton = new javax.swing.JRadioButton();
        _objectBrowserInputButton = new javax.swing.JRadioButton();
        _resultScroll = new javax.swing.JScrollPane();

        setLayout(new java.awt.BorderLayout());

        _splitter.setDividerLocation(50);

        _inputPanel.setLayout(new java.awt.BorderLayout());

        _inputScroller.setViewportView(_editor);

        _inputPanel.add(_inputScroller, java.awt.BorderLayout.CENTER);

        jPanel2.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        _inputToggleGroup.add(_sqlInputButton);
        _sqlInputButton.setSelected(true);
        _sqlInputButton.setText("SQL Edit");
        _sqlInputButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                _sqlInputButtonActionPerformed(evt);
            }
        });
        jPanel2.add(_sqlInputButton);

        _inputToggleGroup.add(_objectBrowserInputButton);
        _objectBrowserInputButton.setText("Objects");
        _objectBrowserInputButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                _objectBrowserInputButtonActionPerformed(evt);
            }
        });
        jPanel2.add(_objectBrowserInputButton);

        _inputPanel.add(jPanel2, java.awt.BorderLayout.NORTH);

        _splitter.setLeftComponent(_inputPanel);
        _splitter.setRightComponent(_resultScroll);

        add(_splitter, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    
    private ObjectTree objectTree;
    
    private void showObjectBrowser() throws SQLException {
        if (objectTree == null) {
            objectTree = objectTreeProvider.get();
            objectTree.setDatabaseConnectionPanel(this);
        } 
        showInputComponent(objectTree);
    }

    private void showInputComponent(JComponent inputComponent) {
        _inputScroller.setViewportView(inputComponent);
    }
    
    private void _sqlInputButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event__sqlInputButtonActionPerformed
        showInputComponent(_editor);
    }//GEN-LAST:event__sqlInputButtonActionPerformed

    private void _objectBrowserInputButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event__objectBrowserInputButtonActionPerformed
        try {
            showObjectBrowser();
        } catch (SQLException e) {
            throw new RuntimeException("error running action: " + e.getMessage(), e);
        }
    }//GEN-LAST:event__objectBrowserInputButtonActionPerformed
    
    /** Getter for property editor.
     * @return Value of property editor.
     *
     */
    public SQLEditor getEditor() {
        return (SQLEditor) _editor;
    }
    
    /** Getter for property editorRowCount.
     * @return Value of property editorRowCount.
     *
     */
    public int getEditorRowCount() {
        return this.editorRowCount;
    }
    
    /** Setter for property editorRowCount.
     * @param editorRowCount New value of property editorRowCount.
     *
     */
    public void setEditorRowCount(int editorRowCount) {
        int oldEditorRowCount = this.editorRowCount;
        this.editorRowCount = editorRowCount;
//        _editor.setRows(editorRowCount);
        firePropertyChange("editorRowCount", oldEditorRowCount, editorRowCount);
    }
    
    /** Getter for property editorColumnCount.
     * @return Value of property editorColumnCount.
     *
     */
    public int getEditorColumnCount() {
        return this.editorColumnCount;
    }
    
    /** Setter for property editorColumnCount.
     * @param editorColumnCount New value of property editorColumnCount.
     *
     */
    public void setEditorColumnCount(int editorColumnCount) {
        int oldEditorColumnCount = this.editorColumnCount;
        this.editorColumnCount = editorColumnCount;
//        _editor.setColumns(editorColumnCount);
        firePropertyChange("editorColumnCount", oldEditorColumnCount, editorColumnCount);
    }
    
    /** Getter for property dividerLocation.
     * @return Value of property dividerLocation.
     *
     */
    public int getDividerInitialLocation() {
        return this.dividerInitialLocation;
    }
    
    /** Setter for property dividerInitialLocation.
     * @param dividerLocation New value of property dividerLocation.
     *
     */
    public void setDividerInitialLocation(int dividerLocation) {
        int oldDividerLocation = this.dividerInitialLocation;
        this.dividerInitialLocation = dividerLocation;
        _splitter.setDividerLocation(dividerInitialLocation);
        firePropertyChange("dividerInitialLocation", oldDividerLocation, dividerLocation);
    }
    
    /** Getter for property dividerSize.
     * @return Value of property dividerSize.
     *
     */
    public int getDividerInitialSize() {
        return this.dividerInitialSize;
    }
    
    /** Setter for property dividerInitialSize.
     * @param dividerSize New value of property dividerInitialSize.
     *
     */
    public void setDividerInitialSize(int dividerSize) {
        int oldDividerSize = this.dividerInitialSize;
        this.dividerInitialSize = dividerSize;
        _splitter.setDividerSize(dividerInitialSize);
        firePropertyChange("dividerInitialSize", oldDividerSize, dividerSize);
    }
    
    /** Getter for property databaseConnection.
     * @return Value of property databaseConnection.
     *
     */
    public DBConnection getDatabaseConnection() {
        return this.databaseConnection;
    }
    
    /** Setter for property databaseConnection.
     * @param databaseConnection New value of property databaseConnection.
     *
     */
    public void setDatabaseConnection(DBConnection databaseConnection) {
        this.databaseConnection = databaseConnection;
    }
    
    /** Getter for property lastExecutedQuery.
     * @return Value of property lastExecutedQuery.
     *
     */
    public String getLastExecutedQuery() {
        return this.lastExecutedQuery;
    }
    
    /** Setter for property lastExecutedQuery.
     * @param lastExecutedQuery New value of property lastExecutedQuery.
     *
     */
    public void setLastExecutedQuery(String lastExecutedQuery) {
        this.lastExecutedQuery = lastExecutedQuery;
    }
    
    /** Execute the query currently selected in the editor.
     * @throws SQLException on error executing query
     */
    public void executeQuery() throws SQLException {
        String sql = getEditor().getSQLCode();
        if (sql == null || sql.length() == 0) {
            setStatusMessage("Error:  No SQL provided.");
            return;
        }
        executeQuery(sql);
    }
    
    /** Execute a query.
     * @param query the SQL to execute
     * @throws SQLException on error executing query
     */
    public synchronized void executeQuery(String query) throws SQLException {
        // are we already running a query?
        if (getQueryExecutionThread() != null) {
            throw new IllegalStateException("A query is already being executed.  Please wait.");
        }
        
        // start the thread.
        QueryExecutionThread exThread = new QueryExecutionThread();
        exThread.setQuery(query);
        exThread.start();
        setQueryExecutionThread(exThread);
    }
    
    /** Getter for property statusMessage.
     * @return Value of property statusMessage.
     *
     */
    public String getStatusMessage() {
        return this.statusMessage;
    }
    
    /** Setter for property statusMessage.
     * @param statusMessage New value of property statusMessage.
     *
     */
    public void setStatusMessage(String statusMessage) {
        String oldStatusMessage = this.statusMessage;
        this.statusMessage = statusMessage;
        firePropertyChange("statusMessage", oldStatusMessage, statusMessage);
    }
    
    /** Display a {@link java.sql.ResultSet} query result graphically.
     * @param results the query results
     * @throws SQLException on error reading results
     * @return result set row count
     */
    public int showResultSet(ResultSet results) throws SQLException {
        JTable table = new ResultSetTable();
        ResultSetDataModel model = new ResultSetDataModel(results);
        TableSorter tableSorter = new TableSorter(model);
        table.setModel(tableSorter);
        tableSorter.setTableHeader(table.getTableHeader());
        
        // show the table.
        showTableResult(table);
        return model.getRowCount();
    }
    
    /** Show the table in the result set area of the panel.  Each column will be sized
     * according to the maximum width of data in the column.
     * @param table the result set table.
     */
    public void showTableResult(JTable table) {
        // size the columns.  This code is not very efficient and should be improved.
        table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        FontMetrics fontMetrics = table.getFontMetrics(table.getFont());
        TableModel model = table.getModel();
        for (int columnNumber = 0; columnNumber < model.getColumnCount(); columnNumber++) {
            String headerValue = model.getColumnName(columnNumber);
            int maxLength = fontMetrics.charsWidth(headerValue.toCharArray(), 0, headerValue.length());
            for (int rowNumber = 0; rowNumber < model.getRowCount(); rowNumber++) {
                Object cellValue = model.getValueAt(rowNumber, columnNumber);
                String value = "NULL";
                if (cellValue != null) { value = cellValue.toString(); }
                int valueLength = fontMetrics.charsWidth(value.toCharArray(), 0, value.length());
                if (valueLength > maxLength) { maxLength = valueLength; }
            }
            table.getColumnModel().getColumn(columnNumber).setPreferredWidth(maxLength + 20);
        }
        
        // display the table.
        showResultDisplay(table);
    }
    
    private void showResultDisplay(JComponent component) {
        _resultScroll.setViewportView(component);
        setResultDisplayComponent(component);
    }
    
    /** Display a string result graphically.
     * @param result the string to display
     */
    public void showStringResult(String result) {
        SQLEditor text = editorProvider.get();
        showResultDisplay(text);
        text.setFont(getEditor().getFont());
        text.setText(result);
        text.setEditable(false);
        text.setCaretPosition(0);
    }
    
    /** Open the database connection associated with this component.
     * @param userId the login user ID
     * @param serverName the server to connect to
     * @param databaseName the database to connect to
     * @param databaseType the type of database being connected to
     * @throws SQLException on error communicating with the database
     * @throws IOException on error reading database connection configuration files.
     * @throws ClassNotFoundException on error finding classes named in the database connection configuration file.
     * @throws InstantiationException on error instantiating classes named in the database connection configuration file.
     * @throws IllegalAccessException on error accessing classes named in the database connection configuration file.
     */
    
    public void openConnection(String userId, String serverName, String databaseName, String databaseType) throws SQLException, IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        DBConnection c = connectionManager.openConnection(userId, serverName, databaseName, databaseType);
        setDatabaseConnection(c);
    }
    
    @Autowired
    private ConnectionManager connectionManager;
    
    /** Close the associated database connection.
     * @throws SQLException on error closing connection
     */
    public void closeConnection() throws SQLException {
        getDatabaseConnection().getJDBCConnection().close();
    }

    public void reconnect() throws SQLException, IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        DBConnection currentConnection = getDatabaseConnection();
        try {
            closeConnection();
        } catch (SQLException e) {
            logger.error("error closing connection as part of reconnect.  Tolerating.", e);
        }
        openConnection(currentConnection.getUserID(), currentConnection.getServerName(), currentConnection.getDatabaseName(), currentConnection.getDatabaseTypeName());
    }
    
    /** Getter for property resultDisplayComponent.
     * @return Value of property resultDisplayComponent.
     *
     */
    public JComponent getResultDisplayComponent() {
        return this.resultDisplayComponent;
    }
    
    /** Setter for property resultDisplayComponent.
     * @param resultDisplayComponent New value of property resultDisplayComponent.
     *
     */
    public void setResultDisplayComponent(JComponent resultDisplayComponent) {
        JComponent oldResultDisplayComponent = this.resultDisplayComponent;
        this.resultDisplayComponent = resultDisplayComponent;
        firePropertyChange("resultDisplayComponent", oldResultDisplayComponent, resultDisplayComponent);
    }
    
    /** Save the latest query results to a file.
     * @param writer the writer to use for saving the results
     * @param w
     * @throws IOException on error writing file.
     */
    public void saveResults(ResultSetWriter writer, Writer w) throws IOException {
        writer.start(w);
        if (getLastExecutedQuery() != null && writer.wantsQuery()) {
            writer.saveQuery(w, getDatabaseConnection().getUserID(),
                    getDatabaseConnection().getServerName(),
                    getLastExecutedQuery());
        }
        writer.startData(w);
        
        if (getResultDisplayComponent() instanceof JTable) {
            saveTableResults(writer, w);
        } else {
            saveTextResults(writer, w);
        }
        
        writer.endData(w);
        writer.finish(w);
    }
    
    private void saveTableResults(ResultSetWriter writer, Writer w) throws IOException {
        JTable table = (JTable) getResultDisplayComponent();
        TableModel model = table.getModel();
        int columnCount = model.getColumnCount();
        int rowCount = model.getRowCount();
        
        if (writer.wantsResultSetHeaders()) {
            String[] headers = new String[columnCount];
            for (int i = 0; i < headers.length; i++) {
                headers[i] = model.getColumnName(i);
            }
            writer.addHeader(w, headers);
        }
        
        for (int i = 0; i < rowCount; i++) {
            String[] row = new String[columnCount];
            for (int j = 0; j < columnCount; j++) {
                Object o = model.getValueAt(i,j);
                if (o != null) {
                    row[j] = model.getValueAt(i, j).toString();
                } else {
                    row[j] = writer.getNullValue();
                }
            }
            writer.addRow(w, row);
        }
    }
    
    private void saveTextResults(ResultSetWriter writer, Writer w) throws IOException {
        JTextArea c = (JTextArea) getResultDisplayComponent();
        writer.addRow(w, new String[] { c.getText() });
    }
    
    /** Getter for property processingStage.
     * @return Value of property processingStage.
     *
     */
    public ProcessingStage getProcessingStage() {
        return this.processingStage;
    }
    
    /** Setter for property processingStage.
     * @param processingStage New value of property processingStage.
     *
     */
    public void setProcessingStage(ProcessingStage processingStage) {
        ProcessingStage oldProcessingStage = this.processingStage;
        this.processingStage = processingStage;
        firePropertyChange("processingStage", oldProcessingStage, processingStage);
    }
    
    public void cancelQuery() throws SQLException {
        if (getQueryExecutionThread() != null) {
            getQueryExecutionThread().cancelQuery();
            setProcessingStage(ProcessingStage.WAITING);
            setQueryExecutionThread(null);
        }
    }
    
    /** Getter for property queryExecutionThread.
     * @return Value of property queryExecutionThread.
     *
     */
    protected synchronized QueryExecutionThread getQueryExecutionThread() {
        return this.queryExecutionThread;
    }
    
    /** Setter for property queryExecutionThread.
     * @param queryExecutionThread New value of property queryExecutionThread.
     *
     */
    protected synchronized void setQueryExecutionThread(QueryExecutionThread queryExecutionThread) {
        this.queryExecutionThread = queryExecutionThread;
    }
    
    public class QueryExecutionThread extends Thread {
        
        /** Holds value of property query. */
        private String query;
        
        /** Holds value of property actualExecutionThread. */
        private ActualExecuteThread actualExecutionThread;
        
        @Override
        public void run() {
            ActualExecuteThread t = new ActualExecuteThread();
            t.setQuery(getQuery());
            t.start();
            setActualExecutionThread(t);
            
            try {
                t.join();
            } catch (InterruptedException e) {}
            
            setQueryExecutionThread(null);
        }
        
        /** Getter for property query.
         * @return Value of property query.
         *
         */
        public String getQuery() {
            return this.query;
        }
        
        /** Setter for property query.
         * @param query New value of property query.
         *
         */
        public void setQuery(String query) {
            this.query = query;
        }
        
        public void cancelQuery() throws SQLException {
            ActualExecuteThread t = getActualExecutionThread();
            t.getStatement().cancel();
        }
        
        /** Getter for property actualExecutionThread.
         * @return Value of property actualExecutionThread.
         *
         */
        public ActualExecuteThread getActualExecutionThread() {
            return this.actualExecutionThread;
        }
        
        /** Setter for property actualExecutionThread.
         * @param actualExecutionThread New value of property actualExecutionThread.
         *
         */
        public void setActualExecutionThread(ActualExecuteThread actualExecutionThread) {
            this.actualExecutionThread = actualExecutionThread;
        }
        
        public class ActualExecuteThread extends Thread {
            
            /** Holds value of property query. */
            private String query;
            
            /** Holds value of property statement. */
            private Statement statement;
            
            @Override
            public void run() {
                try {
                    setStatusMessage("Executing query");
                    boolean returnedResults = false;
                    
                    setProcessingStage(ProcessingStage.RUNNING);
                    int rowCount = -1;
                    Connection c = getDatabaseConnection().getJDBCConnection();
                    Statement s = c.createStatement();
                    statement = s;
                    
                    // Get all the query results and show them.
                    setProcessingStage(ProcessingStage.FORMATTING);
                    boolean nextResults = s.execute(getQuery());
                    int updateCount = 0;
                    while (nextResults || (updateCount = s.getUpdateCount()) >= 0) {
                        if (nextResults) {
                            ResultSet results = s.getResultSet();
                            rowCount = showResultSet(results);
                            returnedResults = true;
                        } else {
                            if (rowCount < 0) { rowCount = 0; }
                            rowCount += updateCount;
                        }
                        nextResults = s.getMoreResults();
                    }
                    setProcessingStage(ProcessingStage.WAITING);
                    
                    // if we are here, the query went fine.
                    String msg = "Query completed successfully";
                    if (returnedResults) {
                        msg += " (" + rowCount + " rows returned).";
                    } else {
                        msg += ".";
                        if (rowCount >= 0) { msg += "  " + rowCount + " rows affected."; }
                    }
                    setStatusMessage(msg);
                    setLastExecutedQuery(getQuery());
                } catch (SQLException e) {
                    setStatusMessage("Error executing query.");
                    logger.error("Error executing query:", e);
                    ExceptionDisplayPanel pnl = new ExceptionDisplayPanel();
                    pnl.setException(e);
                    JOptionPane.showMessageDialog(DatabaseConnectionPanel.this, pnl, "Processing Error", JOptionPane.ERROR_MESSAGE);
                } finally {
                    setProcessingStage(ProcessingStage.WAITING);
                }
                
            }
            
            /** Getter for property query.
             * @return Value of property query.
             *
             */
            public String getQuery() {
                return this.query;
            }
            
            /** Setter for property query.
             * @param query New value of property query.
             *
             */
            public void setQuery(String query) {
                this.query = query;
            }
            
            /** Getter for property statement.
             * @return Value of property statement.
             *
             */
            public Statement getStatement() {
                return this.statement;
            }
            
        }
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JEditorPane _editor;
    private javax.swing.JPanel _inputPanel;
    private javax.swing.JScrollPane _inputScroller;
    private javax.swing.ButtonGroup _inputToggleGroup;
    private javax.swing.JRadioButton _objectBrowserInputButton;
    private javax.swing.JScrollPane _resultScroll;
    private javax.swing.JScrollPane _resultScroller;
    private javax.swing.JSplitPane _splitter;
    private javax.swing.JRadioButton _sqlInputButton;
    private javax.swing.JPanel jPanel2;
    // End of variables declaration//GEN-END:variables
    
    @Autowired
    private Provider<SQLEditor> editorProvider;
    
    /** Holds value of property editorRowCount. */
    private int editorRowCount;
    
    /** Holds value of property editorColumnCount. */
    private int editorColumnCount;
    
    /** Holds value of property dividerInitialLocation. */
    private int dividerInitialLocation;
    
    /** Holds value of property dividerInitialSize. */
    private int dividerInitialSize;
    
    /** Holds value of property databaseConnection. */
    private DBConnection databaseConnection;
    
    /** Holds value of property lastExecutedQuery. */
    private String lastExecutedQuery;
    
    /** Holds value of property statusMessage. */
    private String statusMessage;
    
    /** Holds value of property resultDisplayComponent. */
    private JComponent resultDisplayComponent;
    
    /** Holds value of property processingStage. */
    private ProcessingStage processingStage = ProcessingStage.WAITING;
    
    /** Holds value of property queryExecutionThread. */
    private QueryExecutionThread queryExecutionThread;
    
    @Autowired
    private Provider<ObjectTree> objectTreeProvider;
    
}
